h3 Introduction
p.
  If you want to learn about hacking, then exploiting DS games though their save files can be a great way to learn the basics.
p
  | DS games operate with very little security in place, if you have some code loaded in memory then you can sometimes just jump straight to it, as opposed to in more modern systems such as the 3DS where there is the
  a(href="http://en.wikipedia.org/wiki/NX_bit") NX bit
  | (some parts of memory can be marked as unexecutable) and in the PS Vita where there is also
  a(href="http://en.wikipedia.org/wiki/Address_space_layout_randomization") ASLR
  | (the base of the stack, and some functions are randomly arranged).
h3#who-is-this-aimed-at Who is this aimed at?
p
  | You should have a competent understanding of fairly low level programming. If you don't know what a register is, or the difference between the stack and the heap, then you probably won't get much out of this tutorial.
h3#tools-used Tools used
p
  | You will need an ARM compiler; I will be using devkitARM from
  a(href="http://devkitpro.org/") devkitPro
  | .
p
  | You will need a DS emulator; I recommend using
  a(href="http://desmume.org/") DeSmuME
  | however I have heard that
  a(href="http://problemkaputt.de/gba.htm") NO$GBA
  | also has excellent debugging tools.
p
  | You will need a hex editor to edit save files; I will be using
  a(href="http://www.hhdsoftware.com/free-hex-editor") Hex Editor Neo
  | .
p
  | I will also be using
  a(href="www.cjmweb.net/vbindiff/") VBinDiff
  | which isn't necessary but helps to identify the location of checksums within a save file.
h3#what-is-a-buffer-overflow What is a buffer overflow?
p
  | There are several different types of buffer overflow, however in this tutorial we will just go over the most common:
  a(href="http://en.wikipedia.org/wiki/Stack_buffer_overflow") Stack Smashing
  | ; overflowing a string on the stack into an address which the Program Counter will read from.
p
  | In order to understand what a Stack Smash is and how it works, you will first need to know a little bit about ARM assembly.
p
  | Both ARM processors on the DS have 16 32 bit registers, the first 13 (R0 to R12) can be used for general purpose calculations, and the last 3 have their own special purposes.
p
  | R13, also referred to as SP, is known as the
  a(href="http://en.wikipedia.org/wiki/Stack_register") Stack Pointer
  | ; it is a pointer to the active
  a(href="http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29") stack
  | - a portion of memory where data can be pushed on and off registers.
p
  | R14, also referred to as LR, is known as the
  a(href="http://en.wikipedia.org/wiki/Link_register") Link Register
  | ; it holds the address to return to after a function call.
p
  | R15, also referred to as PC, is known as the
  a(href="http://en.wikipedia.org/wiki/Program_counter") Program Counter
  | ; it holds the address of the instruction that is currently being executed. In ARM, instructions are 4 bytes long, so once an instruction has been completed the PC will be incremented by 4 in order to point to the next instruction, unless the instruction itself modifies the PC. Also note that sometimes code is executed in
  a(href="http://en.wikipedia.org/wiki/ARM_architecture#Thumb") Thumb
  | mode which uses 2 bytes per instruction.
h3#creating-a-model Creating a model
p
  | Let's compile some basic C code to assembly to help us understand how the stack can be modified to control the Program Counter:

code.block.
  #include <nds.h>
  #include <string.h>

  void copy(void) {
    char buffer[8];
    memset(buffer, 0xAA, 8);
  }

  void turnScreenRed(void) {
    REG_DISPCNT = MODE_0_2D;
    VRAM_A_CR = VRAM_ENABLE | VRAM_A_MAIN_BG;
    BG_PALETTE[0] = RGB15(31, 0, 0);
  }

  int main(void) {
    copy();
      
    turnScreenRed();
      
    while(1);
      
    return 0;
  }

p We will use this Makefile to generate assembly from the above C:

code.block.
  include $(DEVKITARM)/ds_rules

  CFLAGS := -I$(LIBNDS)/include -DARM9 -O1 -march=armv5te -mtune=arm946e-s -nodefaultlibs -nostartfiles

  main.s: main.c
      $(CC) main.c $(CFLAGS) -S

p
  | Once we remove some of the clutter from the generated assembly we will be left with this:

code.block.
  .text
      
      .align    2
      .global    copy
      .type    copy, %function
  copy:
      @ args = 0, pretend = 0, frame = 8
      @ frame_needed = 0, uses_anonymous_args = 0
      str    lr, [sp, #-4]!
      sub    sp, sp, #12
      mov    r0, sp
      mov    r1, #170
      mov    r2, #8
      bl    memset
      add    sp, sp, #12
      @ sp needed
      ldr    pc, [sp], #4
      
      .align    2
      .global    turnScreenRed
      .type    turnScreenRed, %function
  turnScreenRed:
      @ args = 0, pretend = 0, frame = 0
      @ frame_needed = 0, uses_anonymous_args = 0
      @ link register save eliminated.
      mov    r2, #65536
      mov    r3, #67108864
      str    r2, [r3]
      mvn    r2, #126
      add    r3, r3, #512
      strb    r2, [r3, #64]
      mov    r2, #31
      mov    r3, #83886080
      strh    r2, [r3]    @ movhi
      bx    lr
      
      .align    2
      .global    main
      .type    main, %function
  main:
      @ Volatile: function does not return.
      @ args = 0, pretend = 0, frame = 0
      @ frame_needed = 0, uses_anonymous_args = 0
      stmfd    sp!, {r3, lr}
      bl    copy
      bl    turnScreenRed

p
  | Let's ignore the first instruction in
  code main
  | for now and just see how
  code copy
  | is called:

code.block.
  bl    copy
  
p
  | This is the
  a(href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489e/Cihfddaf.html") Branch with Link
  | instruction, it puts the address of the instruction after it (PC + 4) into the Link Register, and then jumps to the copy function by setting the PC to the address of it. The address in the Link Register is needed because after the function we called has completed, we want the program to resume executing from the next instruction after
  code bl copy
  | .
p
  | Now let's look at the
  code copy
  | function, here's the first instruction:

code.block.
  str    lr, [sp, #-4]!
  
p
  | This stores the Link Register at the address that the Stack Pointer holds minus 4 bytes. The reason this happens is so that other instructions (such as
  code bl memset
  | ) can modify the Link Register, and then at the end of the function we can restore the value back from the stack. This value tells us where to return to after the function has completed.
p
  | At the end of the function, the address is loaded into the PC, which takes us to the instruction after the
  code bl copy
  | .

code.block.
  ldr    pc, [sp], #4
  
p
  | Now that you understand how our
  code copy
  | function is called, we can run through the whole program.
p To start with, let's just assume that our stack is empty:

code.block.
  Stack Pointer ->
  
p
  | The first instruction in
  code main
  | is:

code.block.
  stmfd    sp!, {r3, lr}
  
p
  | This is the
  a(href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/Cacbgchh.html") Store Multiple Full Descending
  | instruction. It pushes Register 3 and the Link Register onto the stack at the address stored by the Stack Pointer.
p
  | Just as with the
  code copy
  | function, the Link Register is needed on the stack so that code in the body of the function can modify it freely, and then at the end of the function it can be restored so that we can return to the next instruction.
p
  | The reason that Register 3 is also pushed onto the stack is to
  a(href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka4127.html") keep the stack aligned to 8 bytes for function calls
  | .
p At this point the stack will look like this:

code.block.
  Stack Pointer -> R3 (4 bytes)
                 LR (4 bytes)
  
p
  | Then there is a Branch with Link to our
  code copy
  | function:

code.block.
  bl    copy

p
  | So the next instruction will be the one at the start of
  code copy
  | :
pre.
  
p
  | As explained earlier, this will push the Link Register onto the stack; which will now look like this:
pre.
  
p
  | The next instruction moves the Stack Pointer up by 12 bytes to reserve space for our buffer.
pre.
  
p
  | The reason that 12 bytes are reserved instead of just the 8 that we need, is to keep the stack 8 byte aligned for function calls (as mentioned earlier).
p The stack will now look like this:
pre.
  
p
  | The next group of instructions just call
  code memset
  | :
pre.
  
p
  | Parameters for functions are usually stored in Register 0 and onwards. For our
  code memset
  | call the destination is the Stack Pointer (which currently points to our buffer), the value is
  code 0xAA
  | , and the length is
  code 8 bytes
  | .
p
  | This is safe because it only modifies the 8 bytes that we reserved for our buffer.
p The Stack Pointer is then moved down 12 bytes:
pre.
  
p So that it looks the same as it was before we reserved space for the buffer:
pre.
  
p
  | And finally it will take the Link Register that was saved onto the Stack, and load it into the PC:
pre.
  
p
  | If we run this program in DeSmuME, we can verify that the code reaches the
  code turnScreenRed
  | function as intended because the screen turns red.
p
  | Let's modify the
  code memset
  | call to get it to write further down the stack than the buffer:
pre.
  
p
  | If we go back to the stack diagram we will see that the memory that our program expects to be the Link Register will be overflowed into:
pre.
  
p So that the stack will contain this data:
pre.
  
p The Stack Pointer will then be moved down by 12 bytes:
pre.
  
p Giving us this stack:
pre.
  
p So now, when the program reaches this instruction:
pre.
  
p
  | Our PC will load the value
  code 0xAAAAAAAA
  | off of the stack, where it will continue executing code from.
p Let's verify this by loading our ROM into DeSmuME and opening the Disassembler:
p
  img(src="Exploit.png")
p
  | Sure enough, instead of returning to the
  code bl turnScreenRed
  | instruction like it did before, it returned to our
  code 0xAAAAAAAA
  | address and continued executing code from there!
p
  | In a real exploit, we will have the code we want to run loaded somewhere in memory, which we will make the PC jump to instead of the arbitrary
  code 0xAAAAAAAA
  | .
p We can now apply this knowledge to a real game exploit!
h3#choosing-a-target Choosing a target
p
  | All games have a chance of being exploitable, not just low budget indie games, so don't be put off of trying a game just because it
  a(href="http://wiibrew.org/wiki/Twilight_Hack") appears to be well made on the surface
  | .
p
  | For a basic buffer overflow, a good thing to try to exploit is the player name since it's easy to locate in a save file and is often loaded multiple times in a game.
p
  | For other ideas
  a(href="http://dsibrew.org/wiki/DSiWare_VulnList") here
  | 's an interesting list which shows you the kind of things that people try to exploit.
p
  | If you don't want to spend time searching for an exploitable game then here's a hint for you:
  a(href="https://github.com/CTurt/Dara") most FIFA games on the DS are exploitable
  | .
p For this tutorial I will be exploiting the game FIFA 09 (E) DS.
h3#checksums Checksums
p
  | Before we can start modifying save files we will need to get one other thing out of the way,
  a(href="http://en.wikipedia.org/wiki/Checksum") checksums
  | .
p
  | A checksum is a representation of a piece of data that is used to make sure that the data is not corrupt.
p
  | If we just modify a save file without correcting the necessary checksums, and load it into the game, it will be detected as corrupt, and will be deleted.
p
  | Specifically, DS games tend to use
  a(href="http://en.wikipedia.org/wiki/Cyclic_redundancy_check") Cyclic Redundancy Checks
  | (CRCs).
p
  | CRCs are not too complicated and we can usually work them out without having to disassemble the ROM.
p
  | First of all, we will need to dump some save files which are slightly diferent in order to locate where the CRC is.
p
  | I created two different save files in FIFA 09, one with the profile name entered as "AAAAAAAAAA", and the other with the name "AAAAAAAAAB" leaving everything else as default. In DeSmuME, go to File -&#62; Export Backup Memory to write these saves to files.
p Let's analyse the two files with VBinDiff:
p
  img(src="VBinDiff.png")
p
  | We can clearly see that the CRC for this game is 2 bytes long and is located at 0x04 in the save file.
p
  | So now we can write a program which reads the CRC from a save file and prints it to the screen, in C this would look like this:
pre.
  
p
  | Compiling, and running this program with AAAAAAAAAA.sav gives the following output:
pre.
  
p
  | Now let's redirect
  code stdout
  | to a file and run CRCFix on all of the save files at once to get a list like this:
pre.
  
p
  | The more data you have, the easier it will be to work out how the CRCs are generated.
p
  | Basically what we want to do now is work out the difference between these CRCs in order to see how 1 byte changes the resultant CRC.
p
  | We start by seeing how the final byte of the profile name (located at
  code 0x69
  | in the save) affects the CRC, we will work out the difference between AAAAAAAAAB.sav and AAAAAAAAAA.sav:
pre.
  
p
  | To verify that this is always the case, we will also compare AAAAAAAAAC.sav with AAAAAAAAAB.sav:
pre.
  
p
  | Great! We can now confirm that the byte at
  code 0x69
  | changes the CRC by
  code 0xA3
  | . Using this information we can predict that the CRC of AAAAAAAAAD would be
  code AAAAAAAAAC + 0xA3 = 0x0000F775
  | .
p
  | If we do the same process on the byte at
  code 0x68
  | (
  code AAAAAAAABA - AAAAAAAAAA
  | ) we will discover that this byte alters the CRC by
  code 0xA4
  | .
p
  | And the byte at
  code 0x67
  | alters the CRC by
  code 0xA5
  | . Can you spot the pattern yet?
p
  | Using this knowledge we can write our first attempt at calculating the CRC. We will just use the bytes from
  code 0x0020
  | to
  code 0x010D
  | because anything further down in the save uses a different CRC which we don't want to deal with right now:
pre.
  
p
  | Let's try it out! Running AAAAAAAAAA.sav through our application generates
  code 0xF579
  | , however the real CRC is
  code 0xF58C
  | . There is a simple solution to this, work out the difference between your generated CRC and the real CRC:
pre.
  
p And use this as the initial value of the CRC:
pre.
  
p
  | Our application can now generate CRCs which correctly match those already found in the saves!
p
  | Another way to do this, which might be easier for you, is to locate the position of the CRC in RAM and set a breakpoint on it. When the emulator compares the CRC it has calculated with the CRC at this location the breakpoint will be triggered; now you can trace backwards in the disassembly until you find the computation code.
p
  | With the CRC out of the way, it's time to try modifying the save file and looking for crashes!
h3#initial-overflow-attempt Initial overflow attempt
p
  | In FIFA 09 the maximum length for a profile name is 10 bytes (followed by a byte of 0x00 to signify the end of the name), let's try using a longer name:
p
  img(src="Overflow.png")
p
  | Correct the CRC and then import the save file into DeSmuME (make sure to select the correct size).
p After going to My FIFA 09 -&#62; My Profile we are greeted with this:
p
  img(src="Crash.png")
p
  | Look familiar? Our profile name overflowed the stack into an address which the PC read from, we have a stack smash!
h3#refining-the-overflow Refining the overflow
p
  | We know that the PC is only 4 bytes long, so not all of these
  code 0xAA
  | s are necessary, keep removing them until the game stops jumping to
  code 0xAAAAAAAA
  | to find the exact location.
p We now have complete control over the PC.
p
  img(src="Refined.png")
h3#finding-the-jump-address Finding the jump address
p
  | Launch the crash, and then go to Tools -&#62; View Memory -&#62; Dump All. This will dump the memory of arm 9 at the time of the crash.
p
  | Open this with a hex editor and search for something in your save file, like the profile name.
p
  | Find an appropriate location which you can load your payload at (must be aligned to 4 bytes):
p
  img(src="Dump.png")
p
  | In the case of FIFA 09, the location in the file is
  code 0x0028af40
  | , you need to add
  code 0x02000000
  | to this value to get the real address,
  code 0x0228af40
  | .
p
  | Replace the
  code 0xAAAAAAAA
  | in your save file with the real return address, remember that the DS is Little Endian, so the individual bytes of
  code 0x0228af40
  | are
  code 40 af 28 02
  | .
h3#injecting-a-payload Injecting a payload
p
  | Let's compile a very small payload that makes the bottom screen flash different colours:
pre.
  
p
  | We will use this
  code Makefile
  | :
pre.
  
p Here's what our compiled payload looks like:
p
  img(src="Payload.png")
p
  | For this payload it is unnecessary, but you will need to compile with
  code -Ttext=(your return address)
  | if you want to be able to access memory relative to where the payload is loaded.
p
  | With this injected so that the code will be loaded at your return address, and the CRC corrected, you will have your completed save file:
p
  img(src="Final.png")
p
  | If you import this save file and trigger the exploit you should hopefully see your payload running!
p
  img(src="Hacked.png")
p If it just crashes, or does nothing, then:
ul
  li Check that your payload is loaded in memory where you think it is,
  li Check that the PC is going where you want it to,
p The above screenshot shows you how to do both of these things in DeSmuME.
h3#tips Tips
p
  | If you cannot predict exactly where your payload will be loaded in RAM, then you can start it with a list of
  code NOP
  | s, like so:
pre.
  
p
  a(href="http://en.wikipedia.org/wiki/NOP")
    code NOP
  | (short for No Operation) does nothing, and just causes the Program Counter to advance to the next instruction. This means that you don't have to get the address of the first instruction absolutely perfect; as long as you jump somewhere within the list of
  code NOP
  | s all of your real code will still be executed.
p
  | If you're using NO$GBA, you can place this instruction at the start of your payload:
pre.
  
p To trigger a breakpoint.
p
  img(src="NO$GBA.png")
h3#testing-on-real-hardware Testing on real hardware
p
  | The most convenient way is just to use a flashcard. If you want to transfer your save file to a real cartridge you can use
  a(href="http://filetrip.net/file.php?id=2433") NDS Backup Tool WiFi
  | or a hardware solution such as NDS Adaptor Plus.
h3#where-to-go-from-here Where to go from here
p
  | There are many creative ways that you can try to exploit something, from
  a(href="http://smealum.net/ninjhax/") QR codes
  | to
  a(href="https://www.youtube.com/watch?v=zEd4Vw2bmBE") sound
  | . In general, if a program accepts input, there's a chance that you can exploit it! You can also try different systems, such as the
  a(href="http://wololo.net/2009/03/11/finding-gamesaves-exploits-on-the-psp/") PSP
  | which, like the DS, doesn't use the NX bit or ASLR.
